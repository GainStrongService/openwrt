--- linux-5.4.194/drivers/net/ieee802154/sx1278.c	2022-06-27 10:48:00.047853224 +0800
+++ linux-5.4.194/drivers/net/ieee802154/sx1278.c.1	2022-06-29 22:03:38.095349394 +0800
@@ -46,9 +46,6 @@
 #include <linux/regmap.h>
 #include <net/mac802154.h>
 
-
-typedef struct timer_list *compat_timer_arg_t;
-
 /*------------------------------ LoRa Functions ------------------------------*/
 
 #ifndef F_XOSC
@@ -205,6 +202,17 @@
 }
 
 /**
+ * sx127X_set_mode - Set LoRa device's mode register
+ * @map:	the device as a regmap to communicate with
+ * @op_mode:	LoRa device's operation mode register value
+ */
+void
+sx127X_set_mode(struct regmap *map, u8 op_mode)
+{
+	regmap_raw_write(map, SX127X_REG_OP_MODE, &op_mode, 1);
+}
+
+/**
  * sx127X_get_mode - Get LoRa device's mode register
  * @map:	the device as a regmap to communicate with
  *
@@ -262,11 +270,11 @@
 void
 sx127X_set_lorafrq(struct regmap *map, u32 fr)
 {
-	u64 frt64;
-	u32 frt;
+	u64 frt;
 	u8 buf[3];
-	u8 i;
+	s8 i;
 	u32 f_xosc;
+	u8 op_mode;
 
 #ifdef CONFIG_OF
 	/* Set the LoRa module's crystal oscillator's clock if OF is defined. */
@@ -278,16 +286,21 @@
 	f_xosc = xosc_frq;
 #endif
 
-	frt64 = (uint64_t)fr * (uint64_t)__POW_2_19;
-	do_div(frt64, f_xosc);
-	frt = frt64;
-
-	for (i = 2; i >= 0; i--) {
-		buf[i] = frt % 256;
-		frt = frt >> 8;
-	}
+	frt = (uint64_t)fr * (uint64_t)__POW_2_19;
+	do_div(frt, f_xosc);
+
+	for (i = 2; i >= 0; i--)
+		buf[i] = do_div(frt, 256);
 
+	op_mode = sx127X_get_mode(map);
+	/* Set Low/High frequency bit. */
+	if (fr >= 779000000)
+		op_mode &= ~0x8;
+	else if (fr <= 525000000)
+		op_mode |= 0x8;
+	sx127X_set_state(map, SX127X_SLEEP_MODE);
 	regmap_raw_write(map, SX127X_REG_FRF_MSB, buf, 3);
+	sx127X_set_mode(map, op_mode);
 }
 
 /**
@@ -1119,7 +1132,7 @@
 		rf->carrier = carrier_frq;
 
 	/* Set the LoRa chip's RF bandwidth. */
-	if (of_property_read_u32(of_node, "rf-bandwidth", &rf->carrier))
+	if (of_property_read_u32(of_node, "rf-bandwidth", &rf->bw))
 		rf->bw = bandwidth;
 
 	/* Set the LoRa chip's min & max RF channel if OF is defined. */
@@ -1145,7 +1158,7 @@
 	s8 d;
 
 	dev_dbg(regmap_get_device(phy->map),
-		"%s channel: %u", __func__, channel);
+		"%s channel: %u\n", __func__, channel);
 
 	sx1278_ieee_get_rf_config(hw, &rf);
 
@@ -1158,6 +1171,7 @@
 	fr = rf.carrier + d * rf.bw;
 
 	sx127X_set_lorafrq(phy->map, fr);
+	phy->opmode = sx127X_get_mode(phy->map);
 
 	return 0;
 }
@@ -1174,7 +1188,7 @@
 	s32 dbm = sx127X_mbm2dbm(mbm);
 
 	dev_dbg(regmap_get_device(phy->map),
-		"%s TX power: %d mbm", __func__, mbm);
+		"%s TX power: %d mbm\n", __func__, mbm);
 
 	sx127X_set_lorapower(phy->map, dbm);
 
@@ -1186,22 +1200,25 @@
 {
 	struct sx1278_phy *phy = hw->priv;
 	bool do_rx;
+	unsigned long f;
 
 	dev_dbg(regmap_get_device(phy->map), "%s\n", __func__);
 
-	spin_lock(&phy->buf_lock);
+	spin_lock_irqsave(&phy->buf_lock, f);
 	if (!phy->is_busy) {
 		phy->is_busy = true;
 		do_rx = true;
 	} else {
 		do_rx = false;
 	}
-	spin_unlock(&phy->buf_lock);
+	spin_unlock_irqrestore(&phy->buf_lock, f);
 
 	if (do_rx) {
 		sx127X_set_state(phy->map, SX127X_RXSINGLE_MODE);
 		return 0;
 	} else {
+		dev_dbg(regmap_get_device(phy->map),
+			"%s: device is busy\n", __func__);
 		return -EBUSY;
 	}
 }
@@ -1216,10 +1233,13 @@
 	s32 rssi;
 	s32 range = SX1278_IEEE_ENERGY_RANGE;
 	int err;
+	unsigned long f;
 
 	skb = dev_alloc_skb(IEEE802154_MTU);
 	if (!skb) {
 		err = -ENOMEM;
+		dev_err(regmap_get_device(phy->map),
+			"%s: driver is out of memory\n", __func__);
 		goto sx1278_ieee_rx_err;
 	}
 
@@ -1233,16 +1253,15 @@
 
 	ieee802154_rx_irqsafe(hw, skb, lqi);
 
-	spin_lock(&phy->buf_lock);
-	phy->is_busy = false;
-	spin_unlock(&phy->buf_lock);
-
 	dev_dbg(regmap_get_device(phy->map),
 		"%s: len=%u LQI=%u\n", __func__, len, lqi);
 
-	return 0;
+	err = 0;
 
 sx1278_ieee_rx_err:
+	spin_lock_irqsave(&phy->buf_lock, f);
+	phy->is_busy = false;
+	spin_unlock_irqrestore(&phy->buf_lock, f);
 	return err;
 }
 
@@ -1252,6 +1271,7 @@
 	struct sx1278_phy *phy = hw->priv;
 	struct sk_buff *tx_buf = phy->tx_buf;
 	bool do_tx = false;
+	unsigned long f;
 
 	dev_dbg(regmap_get_device(phy->map),
 		"%s: len=%u\n", __func__, tx_buf->len);
@@ -1261,13 +1281,13 @@
 		phy->post_tx_done = true;
 	}
 
-	spin_lock(&phy->buf_lock);
+	spin_lock_irqsave(&phy->buf_lock, f);
 	if (!phy->is_busy) {
 		phy->is_busy = true;
 		do_tx = true;
 		phy->one_to_be_sent = false;
 	}
-	spin_unlock(&phy->buf_lock);
+	spin_unlock_irqrestore(&phy->buf_lock, f);
 
 	if (do_tx) {
 		/* Set chip as TX state and transfer the data in FIFO. */
@@ -1275,6 +1295,8 @@
 		regmap_write_async(phy->map, SX127X_REG_OP_MODE, phy->opmode);
 		return 0;
 	} else {
+		dev_dbg(regmap_get_device(phy->map),
+			"%s: device is busy\n", __func__);
 		return -EBUSY;
 	}
 }
@@ -1284,15 +1306,16 @@
 {
 	struct sx1278_phy *phy = hw->priv;
 	struct sk_buff *skb = phy->tx_buf;
+	unsigned long f;
 
 	dev_dbg(regmap_get_device(phy->map), "%s\n", __func__);
 
 	ieee802154_xmit_complete(hw, skb, false);
 
-	spin_lock(&phy->buf_lock);
+	spin_lock_irqsave(&phy->buf_lock, f);
 	phy->is_busy = false;
 	phy->tx_buf = NULL;
-	spin_unlock(&phy->buf_lock);
+	spin_unlock_irqrestore(&phy->buf_lock, f);
 
 	return 0;
 }
@@ -1302,12 +1325,13 @@
 {
 	struct sx1278_phy *phy = hw->priv;
 	int ret;
+	unsigned long f;
 
 	dev_dbg(regmap_get_device(phy->map), "%s\n", __func__);
 
 	WARN_ON(phy->suspended);
 
-	spin_lock(&phy->buf_lock);
+	spin_lock_irqsave(&phy->buf_lock, f);
 	if (phy->tx_buf) {
 		ret = -EBUSY;
 	} else {
@@ -1316,7 +1340,7 @@
 		phy->post_tx_done = false;
 		ret = 0;
 	}
-	spin_unlock(&phy->buf_lock);
+	spin_unlock_irqrestore(&phy->buf_lock, f);
 
 	return ret;
 }
@@ -1328,6 +1352,7 @@
 
 	dev_dbg(regmap_get_device(phy->map), "interface up\n");
 
+	sx1278_ieee_set_channel(hw, 0, hw->phy->current_channel);
 	phy->suspended = false;
 	sx127X_start_loramode(phy->map);
 	phy->opmode = sx127X_get_mode(phy->map);
@@ -1361,6 +1386,7 @@
 	u8 flags;
 	u8 state;
 	bool do_next_rx = false;
+	unsigned long f;
 
 	flags = sx127X_get_loraallflag(phy->map);
 	state = sx127X_get_state(phy->map);
@@ -1369,9 +1395,9 @@
 		sx127X_clear_loraflag(phy->map, SX127X_FLAG_RXTIMEOUT
 						| SX127X_FLAG_PAYLOADCRCERROR
 						| SX127X_FLAG_RXDONE);
-		spin_lock(&phy->buf_lock);
+		spin_lock_irqsave(&phy->buf_lock, f);
 		phy->is_busy = false;
-		spin_unlock(&phy->buf_lock);
+		spin_unlock_irqrestore(&phy->buf_lock, f);
 		do_next_rx = true;
 	} else if (flags & SX127X_FLAG_RXDONE) {
 		sx1278_ieee_rx_complete(phy->hw);
@@ -1423,9 +1449,9 @@
  * @arg:	the general argument for this callback function
  */
 static void
-sx1278_timer_isr(compat_timer_arg_t arg)
+sx1278_timer_isr(struct timer_list *timer)
 {
-	struct sx1278_phy *phy = (struct sx1278_phy *)arg;
+	struct sx1278_phy *phy = container_of(timer, struct sx1278_phy, timer);
 
 	schedule_work(&phy->irqwork);
 }
@@ -1487,9 +1513,8 @@
 
 	INIT_WORK(&phy->irqwork, sx1278_timer_irqwork);
 
+	timer_setup(&phy->timer, sx1278_timer_isr, 0);
 	phy->timer.expires = jiffies_64 + HZ;
-	timer_setup(&phy->timer, sx1278_timer_isr, (unsigned long)phy);
-	
 
 	spin_lock_init(&phy->buf_lock);
 
